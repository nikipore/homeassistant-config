{
	"clock-timer": {
		"label": {
			"clock-timer": "Zeitschaltuhr",
			"clock-timer-palette": "Zeitschaltuhr",
			"output1": "payload basierend auf Regel",
			"output2": "status Objekt",
			"payloadDefault": "payload",
			"payloadDefaultOffset": "Offset",
			"payloadDefaultFormat": "Format",
			"overwriteExpire": "verfällt",
			"ruleCondition": "nur wenn",
			"ruleConditionThreshold": "Schwelle",
			"ruleAndOr": "und/oder",
			"ruleCondNone": "N/A",
			"ruleCondAnd": "und",
			"ruleCondOr": "oder",
			"ruleTimeFrom": "↧ von",
			"ruleTimeUntil": "↥ bis",
			"ruleTimeNone": "N/A",
			"ruleTimeMax": "spätestens (max)",
			"ruleTimeMin": "frühestens (min)",
			"ruleTimeDays": "nur an folgenden Tagen",
			"ruleTimeMonths": "nur an folgenden Monaten",
			"ruleDescription": "Beschreibung",
			"rulePayload": "Payload:",
			"rulePayloadND": "Kein Payload",
			"ruleResetOverwrite": "manuelle Überschreibung verfällt wenn die Regel aktiv wird",
			"ruleTopic": "Topic:",
			"ruleImportance":"Wichtung der Regel",
			"ruleTimeLimitStart": "only from",
			"ruleTimeLimitEnd": "to",
			"time": "Zeit",
			"name": "name",
			"showEnhSettings": "Erweiterte Einstellungen",
			"outputs": "Ausgänge",
			"offset": "Zeit offset",
			"offset-timeMin": "früheste (min) offset",
			"offset-timeMax": "späteste (max) offset",
			"singleOutput": "einzeln (1)",
			"splitOutput": "doppelt (2)",
			"btnAdd": "hinzufügen",
			"btnSort": "sortieren",
			"btnClear": "leeren",
			"dialogtitle": "Regel bearbeiten",
			"autoTrigger": "automatisch triggern",
			"autoTrigger2": "dynamisch aber max aller",
			"startDelay": "Ausgabe bei Start verzögern",
			"timeconstraintshow": "zeige zusätzliche Zeitbeschränkungen",
			"timeconstrainthide": "verberge zusätzliche Zeitbeschränkungen",
			"validForDays": "gültige Tage",
			"validForMonths": "gültige Monate",
			"validForDates":"Gültigkeitsdauer (Jahr wird ignoriert)",
			"specialDays": "spezielle tage",
			"onlyEven": "nur gerade",
			"onlyOdd": "nur ungerade",
			"onlyEvenDays": "nur gerade Tage",
			"onlyOddDays": "nur ungerade Tage",
			"editRule": "Regel editieren",
			"duplicateRule": "Regel duplizieren"
		},
		"placeholder": {
			"payloadDefault": "payload if no other used",
			"payloadDefaultOffset": "",
			"payloadDefaultFormat": "",
			"overwriteExpire": "(opt) Dauer nasch der eine manuelle Einstellung verfällt",
			"name": "Name",
			"expiryperiod": "120",
			"outputs": "Anzahl der Ausgänge",
			"btnAdd": "neue leere Regel hinzufügen",
			"btnSort": "alle Regeln sortieren, Achtung dies kann das Verhalten ändern!",
			"btnClear": "alle Regeln entfernen",
			"condoperand": "operand",
			"time": "Zeit",
			"offset": "Zeit offset",
			"level": "Behanghöhe",
			"ruleImportance": "definiert eine wichtung der Regel gegenüber manueller Einstellung (überschreiben). Nur Überschreibungen mit gleicher oder höherer Wichtung können diese Regel übersteuern.",
			"ruleTopic":"Erlaubt es die topic der ausgesendeten Nachricht speziell für die Regel angepasst werden. Wenn diese leer ist, wird die Standard topic verwendet.",
			"resetOverwrite": "Wenn angehakt, wird eine manuelle Einstellung (überschreiben) zurückgesetzt, wenn diese Regel erstmalig aktif geht",
			"ruleTimeDays": "Wählen Sie Tage aus, an denen die Regel gültig sein soll",
			"ruleTimeMonths": "Wählen Sie Monate aus, an denen die Regel gültig sein soll",
			"autoTrigger": "automatisches triggern der Neuberechnung der Rollladenposition nach einer dynamischen Zeitspanne",
			"startDelay": "0 - aus",
			"startDelay2": "verzögert die Ausgabe auf dem ersten Ausgang um die angegebene Zeit. Auf 0 setzen zum abschalten.",
			"start":"tt.mm",
			"end":"tt.mm"
		},
		"text": {
			"time": "Zeitsteuerung: Es werden nur Zeilen ausgewertet, bei denen die Eigenschaft <b>nicht verwendet</b> oder <em>true</em> ist. <br> <b>bis</b>: Die erste übereinstimmende Zeile wird verwendet, wobei die definierte Zeit <b>nicht verwendet</b> oder größer als <b>now</b> ist. <br> <b>von</b>: Die letzte übereinstimmende Zeile wird verwendet, wo die angegebene Zeit <b>nicht verwendet</b> oder weniger als <b>der aktuelle Zeitpunkt</b> ist. <br>",
			"payloadDefault":"Wenn keine Regel zutrifft, wird der folgende payload gesendet.",
			"overwrite": "manuelles Überschreiben der Rollladenposition"
		},
		"tips": {
			"documentation": "<a href=\"https://github.com/rdmtc/node-red-contrib-sun-position/wiki/clock-timer\">Dokumentation und Beispiele</a>"
		},
		"reasons": {
			"overwriteNoExpire": "manuell überschrieben (Wichtigkeit __importance__), kein Verfall",
			"overwriteExpire": "manuell überschrieben (Wichtigkeit __importance__), verfällt __dateISO__",
			"default": "Position ist auf Standard gesetzt, weil keine Regel zutrifft",
			"ruleTime": "Position durch Zeitregel - rule __timeOp__ __timeLocal__ [rule __number__]",
			"ruleCond": "Position durch bedingte Regel __text__ [rule __number__]",
			"ruleTimeCond": "Position durch Zeit Regel __timeOp__ __timeLocal__ und Bedingung __text__ [rule __number__]",
			"rule": "Position durch feste Regel __number__",
			"ruleMin": "__org__ (__level__ ist unter minimum) [__number__] __name__",
			"ruleMax": "__org__ (__level__ ist über maximum) [__number__] __name__",
			"startDelay": "verzögerter Start bis __dateISO__"
		},
		"states": {
			"overwriteNoExpire": "überschrieben [Prio=__importance__]",
			"overwriteExpire": "überschrieben [Prio=__importance__], bis __timeLocal__",
			"default": "Standard",
			"ruleTime": "__timeOp__ __timeLocal__ [rule __number__]",
			"ruleCond": "__textShort__ [rule __number__]",
			"ruleTimeCond": "__timeOp__ __timeLocal__ + cond __operatorText__ [rule __number__]",
			"rule": "durch feste Regel __number__",
			"ruleMin": "__org__ [min rule __number__]",
			"ruleMax": "__org__ [max rule __number__]",
			"startDelay": "verzögerter Start"
		},
		"errors": {
			"warning": "Warnung: __message__",
			"internal": "Fehler: __message__",
			"error-time": "Fehler bei Ermittlung der Zeit: __message__",
			"getPropertyData": "Fehler bei der Ermittlung der Bedingung: \"__message__\" skipping time",
			"usingTempValue": "Wert von __type__.__value__ kann nicht ermitteln werden und es wird der gespeicherte Wert \"__usedValue__\" verwendet!",
			"notEvaluableProperty": "kann den Wert von __type__.__value__ nicht ermitteln, verwende \"__usedValue__\"!"
		}
	}
}
